#!/usr/bin/env ruby
require 'tmpdir'
require 'fileutils'

CMD = File.basename($0)

module SuperBlame
  class BasicRepo
    def initialize(repo)
      @repo = repo
      @env = { "GIT_DIR" => @repo }
    end

    def inspect
      %Q[<#{self.class} @repo="#{@repo}">]
    end

    def git_clone(target)
      system("git", "clone", "--quiet", "--shared", "--bare", @repo, target)
    end

    def git_cat_file(id)
      IO.popen(@env, ["git", "cat-file", id]) do |p|
        return p.read
      end
    end

    def git_hash_object(data)
      IO.popen(@env, ["git", "hash-object", "-w", "--stdin"], "r+") do |p|
        p.write(data)
        p.close_write
        return p.gets.strip
      end
    end
    
    def git_ls_tree(tree)
      IO.popen(@env, ["git", "ls-tree", "-z", tree], "r") do |pin|
        return pin.each_line("\0").map do |line|
          # <mode> SP <type> SP <object> TAB <file>
          m = line.chomp("\0").match(/^(?<mode>\w+) (?<type>\w+) (?<id>\w+)\t(?<name>.*)/m)
          Hash[ m.names.map {|k| [k.to_sym, m[k]] } ]
        end
      end
    end

    def git_mktree(entries)
      IO.popen(@env, ["git", "mktree", "-z"], "r+") do |pout|
        entries.each do |e|
          pout.print("#{e[:mode]} #{e[:type]} #{e[:id]}\t#{e[:name]}\0")
        end
        pout.close_write
        return pout.gets.strip
      end
    end

    def git_commit_tree(tree, parent)
      IO.popen(@env, ["git", "commit-tree", tree, "-p", parent, "-m", "auto-created by #{CMD}"], "r") do |pin|
        return pin.gets.strip
      end
    end

    FOLLOW = %w[--follow -M -C --find-copies-harder]
    def git_log(file)
      result = []
      IO.popen(@env, ["git", "--no-pager", "log", "--format=%H %P", "--name-status", *FOLLOW, "--", file]) do |pin|
        pin.each_line do |line|
          case line
          when /^([0-9a-f]+) ([0-9a-f]+)/ # %H:commit hash, %P:parent hashes
            result << { :commit => $1, :orig_commit => $2 }
          when /^A\t(.+)/ # add
            result[-1].merge!({ :type => :add, :file => $1 })
          when /^D\t(.+)/ # delete
            result[-1].merge!({ :type => :delete, :orig_file => $1 })
          when /^M\t(.+)/ # modify
            result[-1].merge!({ :type => :modify, :file => $1 })
          when /^R(\d+)\t(.+)\t(.+)/ # rename
            result[-1].merge!({ :type => :rename, :sim => $1.to_i, :file => $3, :orig_file => $2 })
          when /^C(\d+)\t(.+)\t(.+)/ # copy
            result[-1].merge!({ :type => :copy, :sim => $1.to_i, :file => $3, :orig_file => $2 })
          end
        end
      end
      result
    end

    def git_blame(file, commit)
      result = []
      commits = {}
      IO.popen(@env, ["git", "--no-pager", "blame", "--porcelain", "--", file, commit]) do |pin|
        current = nil
        pin.each_line do |line|
          line.chomp!
          case line
          when /^([0-9a-f]{40}) (\d+) (\d+) (\d+)/ # commit, line-orig, line-current, next-start
            commits[$1] ||= { :id => $1 }
            current = { :commit => commits[$1], :line_orig => $2.to_i, :line_current => $3.to_i }
          when /^([-a-z]+) (.*)/ # attribute
            current[:commit][$1] = $2
          when /^\t(.*)/ # line
            current[:body] = $1
            result << current.dup
            current[:line_current] += 1
          end
        end
      end
      result
    end

    def delete
      FileUtils.rm_rf(@repo)
    end
  end

  class Repo < BasicRepo
    # Make a temprary clone of a repository on TMPDIR
    def clone
      tmpdir = Dir.mktmpdir(CMD)  # `mktemp -d -t #{CMD}`
      git_clone(tmpdir)
      new_repo = Repo.new(tmpdir)
      return new_repo unless block_given?
      begin
        yield new_repo
      ensure
        new_repo.delete
      end
    end

    # Replace the contents of a file of a commit to the given blob
    def replace(commit, path, blob)
      new_tree = replace_sub("#{commit}^{tree}", path.split('/'), blob)
      git_commit_tree(new_tree, commit)
    end
    def replace_sub(tree, segs, blob)
      return blob if segs.empty?
      entries = git_ls_tree(tree)
      entries.select {|e| e[:path] == segs[0] }.each do |e|
        e[:id] = replace_sub(e[:id], segs.drop(1), blob)
      end
      git_mktree(entries)
    end

    def extract_tracespec(file)
      git_log(file).select {|c| [:rename, :copy].include?(c[:type]) }
    end
  end

  class Blamer
  end
end

orig_repo = ARGV.shift
SuperBlame::Repo.new(orig_repo).clone do |repo|
  #repo.extract_tracespec(ARGV.shift).each {|e| p e }
  repo.git_blame(ARGV.shift, ARGV.shift).each {|e| p e }
end
